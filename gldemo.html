<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <script src="math32.js"></script>
    <script src="shadercompiler.js"></script>
    <script src="imageloader.js"></script>
    <script src="sounds.js"></script>
    <script src="canvasmanager.js"></script>
    <script src="dynamicvao.js"></script>
    <script src="scene.js"></script>
    <script src="engine.js"></script>
</head>
<body>
<h1>Basic Tests: WebGL</h1>
<div id="canvas-container" style="height:70vh; width:100%"></div>

<script id="shader-background-v" type="x-shader/x-vertex">#version 300 es
in vec2 vertex;
out vec2 world_coord;
uniform mat3 inverse_view;

void main() {
    gl_Position = vec4(vertex,0.0,1.0);
    world_coord = (inverse_view * vec3(vertex,1.0)).xy;
}
</script>

<script id="shader-background-f" type="x-shader/x-fragment">#version 300 es
precision highp float;
out vec4 color;
in vec2 world_coord;

void main() {
    color = vec4(world_coord*0.1+0.5, 0.5, 1.0);
}
</script>
<script>

/*
 * A custom render pass that uses the custom shaders
 */
class BackgroundPass extends RenderPass {
    constructor(gl,scene,program) {
        super(gl,program);
        this.vao = new SimpleVAO(gl,program,scene.square_vao);
        this.inverse_view_loc = gl.getUniformLocation(program,"inverse_view");
        this.inverse_view = new Mat();
    }
    update(scene,dt) {
        Mat.Inv(this.inverse_view,scene.view);
    }
    draw(gl) {
        gl.useProgram(this.program);
        gl.uniformMatrix3fv(this.inverse_view_loc,false,this.inverse_view.a);
        this.vao.draw(gl);
    }
}

class DemoEngine extends Engine {
    setup() {
        // Background pass
        this.backgroundpass = new BackgroundPass(this.gl,
            this.scene,
            this.sc.programs.get('background')
        );
        this.scene.addPass(this.backgroundpass);
        // Sprite pass
        if (this.il.textures.has('spritesheet')) {
            this.spritepass = new SpritePass(this.gl,
                this.scene,
                this.sc.programs.get('sprite'),
                this.il.textures.get('spritesheet'),
            );
            this.scene.addPass(this.spritepass);
        }
        // Make some sprites
        const sprites = [];
        for (let i=0; i<1; ++i) {
            sprites.push(this.spritepass.dvao.acquire(this.gl));
        }
        for (const sprite of sprites) {
            sprite.model.a[6] += Math.random()*0.02-0.01;
            sprite.model.a[7] += Math.random()*0.02-0.01;
            sprite.uv.a[0] += Math.random()*0.02-0.01;
            sprite.uv.a[1] += Math.random()*0.02-0.01;
            sprite.uv.a[3] += Math.random()*0.02;
            sprite.uv.a[4] += Math.random()*0.02-0.01;
        }
    }
    update(dt) {
        this.scene.view.translationeq(this.cm.mouse_x,this.cm.mouse_y);
        this.scene.view.a[0] = 1/this.cm.aspectRatio;
    }
}

const engine = new DemoEngine(
    canvas_container = document.getElementById("canvas-container"),
    shader_programs = {
        background:['shader-background-v','shader-background-f']
    },
    images = {
        spritesheet:'texture.png'
    },
    music = {
        "negentropy": "sound/Chad_Crouch_-_Negentropy.mp3"
    },
    sfx = {
        "hit": "sound/hit.mp3"
    },
);

</script>

</div>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <script src="math32.js"></script>
    <script src="shadercompiler.js"></script>
    <script src="canvasmanager.js"></script>
    <script src="dynamicvao.js"></script>
</head>
<body>
<h1>Basic Tests: WebGL</h1>
<div id="fps">Loading...</div>

<div id="canvas-container" style="height:70vh; width:100%"></div>

<script id="shader-v" type="x-shader/x-vertex">#version 300 es
out vec3 vcolor;
in vec2 vertex;
in float s;
uniform float t;
uniform mat3 view;

void main() {
    float u = float(gl_InstanceID)/10000.0;
    //mat3 model = transpose(mat3(model_x,model_y,vec3(0.0,0.0,1.0)));
    mat2 m = mat2(
        sin(u*t), cos(u*t),
        -cos(u*t), sin(u*t)
    )*0.025;
    vec2 pos = m*vertex + vec2(3.0*s,s*sin(s*10.0+0.1*t));
    gl_Position = vec4(view * vec3(pos,1.0),1.0);
    
    vcolor = vec3(vertex*0.5+0.5,0.5);
}
</script>

<script id="shader-f" type="x-shader/x-fragment">#version 300 es
precision highp float;
out vec4 color;
in vec3 vcolor;

void main() {
    color = vec4(vcolor, 1.0);
}
</script>
<script>

function start(canvasManager) {
    const gl = canvasManager.gl;
    const sc = new ShaderCompiler(gl,
        {'shader':['shader-v','shader-f']},
    );
    for (const e of sc.errors) {
        console.log(e.toString());
    }
    const program = sc.programs.get('shader');
    //const uniforms = new Uniforms(sc.uniformProfiles.get('shader'));
    
    // Initial gl setup
    gl.useProgram(program);
    const t_loc = gl.getUniformLocation(program,"t");
    const view_loc = gl.getUniformLocation(program,"view");
    const view = new Mat();
    
    // VAO
    const vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    
    // Setting up square geometry to get around the,
    // "drawArraysInstanced: One active vertex attrib (if any are active) must have a divisor of 0."
    // bug.
    const square = new Float32Array([
        -1.0,-1.0,
        1.0,-1.0,
        -1.0,1.0,
        1.0,1.0,
    ]);    
    const square_buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, square_buffer);
    gl.bufferData(gl.ARRAY_BUFFER, square, gl.STATIC_DRAW);
    
    const dvao = new DynamicVAO(gl,program,square_buffer,{
        "s":{'type':'scalar','dynamic':true},
    },1);
    //const object1 = dvao.acquire(gl);
    const objects = [];
    for (let i=0; i<1000; ++i) {
        const o = dvao.acquire(gl);
        o.s.set(i/1000);
        objects.push(o);
    }
    console.log(dvao);
    let timer = 0;
    let frames = 0;
    let last_t = null;
    (function loop(t) {
        cm.updateSize();
        if (last_t !== null) {
            const dt = t-last_t;
            timer += dt;
            frames += 1;
            if (timer > 100) {
                const fps = 1000*frames/timer;
                document.getElementById("fps").textContent = fps.toFixed(3) + " fps";
                frames = 0;
                timer = 0;
            }
            view.translationeq(cm.mouse_x,cm.mouse_y);
            view.a[0] = 1/cm.aspectRatio;
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.uniform1f(t_loc,t*0.01);
            gl.uniformMatrix3fv(view_loc,false,view.a);
            let i = Math.floor(1000*Math.random());
            objects[i].s.set(-objects[i].s.a[0]);
            dvao.draw(gl);
            //gl.drawArraysInstanced(gl.TRIANGLE_STRIP,0,4,N_INSTANCES);
        }
        last_t = t;
        window.requestAnimationFrame(loop);
    })(null);
}

const cm = new CanvasManager(document.getElementById("canvas-container"));
if (cm.gl !== null) {
    start(cm)
};

</script>

</div>
</body>
</html>

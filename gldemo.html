<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <script src="math32.js"></script>
    <script src="shadercompiler.js"></script>
    <script src="canvasmanager.js"></script>
</head>
<body>
<h1>Basic Tests: WebGL</h1>
<div id="fps">Loading...</div>

<div id="canvas-container" style="height:70vh; width:100%"></div>

<script id="shader-v" type="x-shader/x-vertex">#version 300 es
out vec3 vcolor;
in vec2 vertex;
in float s;
uniform float t;
uniform mat3 view;

void main() {
    float u = float(gl_InstanceID)/10000.0;
    //mat3 model = transpose(mat3(model_x,model_y,vec3(0.0,0.0,1.0)));
    mat2 m = mat2(
        sin(u*t), cos(u*t),
        -cos(u*t), sin(u*t)
    )*0.025;
    vec2 pos = m*vertex + vec2(3.0*s,sin(s*10.0+0.1*t));
    gl_Position = vec4(view * vec3(pos,1.0),1.0);
    
    vcolor = vec3(vertex*0.5+0.5,0.5);
}
</script>

<script id="shader-f" type="x-shader/x-fragment">#version 300 es
precision highp float;
out vec4 color;
in vec3 vcolor;

void main() {
    color = vec4(vcolor, 1.0);
}
</script>
<script>

class DVBO {
    constructor(gl,elementSize,nElements,dynamic=true) {
        this.elementSize = elementSize;
        this.nElements = nElements;
        this.a = new Float32Array(nElements*elementSize);
        this.created = false;
        this.must_update = dynamic;
        this.dynamic = dynamic;
        this.vbo = gl.createBuffer(); // Awaiting first data upload
    }
    copy_from(old_dvbo) {
        this.a.set(old_dvbo.a.subarray(0,old_dvbo.a.length));
    }
    subarray(index) {
        return this.a.subarray(index*this.elementSize, (index+1)*this.elementSize);
    }
    rebase(index,arrayfloats) {
        arrayfloats.a = this.subarray(index);
    }
    acquire(index) { // Meant to be overridden
        return new ArrayFloats(this.subarray(index));
    }
    drawMode(gl) {
        return this.dynamic ? gl.STREAM_DRAW : gl.STATIC_DRAW;
    }
    // Creates VBO on GPU (first data upload)
    create(gl) {
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo);
        gl.bufferData(gl.ARRAY_BUFFER, this.a, this.drawMode(gl));
    }
    // Updates VBO on GPU
    update(gl) {
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo);
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.a, 0, this.a.length);
    }
    // Deletes VBO on GPU
    delete(gl) {
        gl.deleteBuffer(this.vbo);
    }
    prepare(gl) { // Prepares for rendering
        if (!this.created) {
            this.create(gl);
            this.created = true;
        } else {
            if (this.must_update) {
                this.update(gl);
                if (!this.dynamic) {
                    this.must_update = false;
                }
            }
        }        
    }
}

class ScalarDVBO extends DVBO {
    constructor(gl,nElements,dynamic=true) {
        super(gl,1,nElements,dynamic);
    }
    acquire(index) {
        return new AbstractScalar(this.subarray(index));
    }
}

class VecDVBO extends DVBO {
    constructor(gl,nElements,dynamic=true) {
        super(gl,2,nElements,dynamic);
    }
    acquire(index) {
        return new AbstractVec(this.subarray(index));
    }
}

class MatDVBO extends DVBO {
    constructor(gl,nElements,dynamic=true) {
        super(gl,9,nElements,dynamic);
    }
    acquire(index) {
        return new AbstractMat(this.subarray(index)).set(); // Set to identity matrix
    }
}

class DynamicVAO {
    constructor(gl,program,square_vbo,channels,size=1) {
        this.square_vbo = square_vbo;
        this.channels = channels;
        this.recycled_objects = [];
        this.object_indices = new Map();
        this.size = size;
        this.head = 0;
        // Find locations in program
        this.vertex_loc = gl.getAttribLocation(program,'vertex');
        if (this.vertex_loc < 0) {
            console.error("Shader missing the absolutely essential 'vertex' location.");
        }
        this.locations = new Map();
        this.malformed_names = new Set();
        for (const name in channels) {
            const channel = channels[name];
            if (channel.type === "scalar" || channel.type === "vec") {
                const loc = gl.getAttribLocation(program,name);
                if (loc < 0) {
                    console.error("Could not find attribute",name);
                    this.malformed_names.add(name);
                } else {
                    this.locations.set(name,loc);
                }
            } else if (channel.type === "mat") {
                const loc_x = gl.getAttribLocation(program,name+'_x');
                const loc_y = gl.getAttribLocation(program,name+'_y');
                if (loc_x < 0 || loc_y < 0) {
                    console.error("Could not find attribute",name,"because we missed",loc_x<0 ? name+'_x':'',loc_y<0 ? name+'_y':'');
                    this.malformed_names.add(name);
                } else {
                    this.locations.set(name,[loc_x,loc_y]);
                }
            } else {
                this.malformed_names.add(name);
            }
        }
        // Construct initial VAO
        this.vao = null;
        this.construct(gl,size);
    }
    construct(gl,size) {
        this.vao = gl.createVertexArray();
        gl.bindVertexArray(this.vao);
        gl.bindBuffer(gl.ARRAY_BUFFER,this.square_vbo);
        gl.vertexAttribPointer(this.vertex_loc, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(this.vertex_loc);
        this.DVBOs = new Map();
        for (const name in this.channels) {
            if (!this.locations.has(name)) continue; // Skip names that we don't have locations for. We don't have locations for names that weren't in the shader.
            const channel = this.channels[name];
            const loc = this.locations.get(name);
            if (channel.type === "scalar") {
                const DVBO = new ScalarDVBO(gl,size,channel.dynamic);
                this.DVBOs.set(name,DVBO);
                gl.bindBuffer(gl.ARRAY_BUFFER,DVBO.vbo);
                gl.vertexAttribPointer(loc, 1, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(loc);
                gl.vertexAttribDivisor(loc, 1);
            } else if (channel.type === "vec") {
                const DVBO = new VecDVBO(gl,size,channel.dynamic);
                this.DVBOs.set(name,DVBO);
                gl.bindBuffer(gl.ARRAY_BUFFER,DVBO.vbo);
                gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(loc);
                gl.vertexAttribDivisor(loc, 1);
            } else if (channel.type === "mat") {
                const DVBO = new MatDVBO(gl,size,channel.dynamic);
                this.DVBOs.set(name,DVBO);
                gl.bindBuffer(gl.ARRAY_BUFFER,DVBO.vbo);
                gl.vertexAttribPointer(loc[0], 3, gl.FLOAT, false, 4*9, 4*0);
                gl.enableVertexAttribArray(loc[0]);
                gl.vertexAttribDivisor(loc[0], 1);
                gl.vertexAttribPointer(loc[1], 3, gl.FLOAT, false, 4*9, 4*3);
                gl.enableVertexAttribArray(loc[1]);
                gl.vertexAttribDivisor(loc[1], 1);
            }
        }
        this.size = size;
    }
    expand(gl,size) {
        console.log(size);
        this.delete(gl);
        const old_DVBOs = this.DVBOs;
        this.construct(gl,size);
        // Move over backing
        for (const [object,index] of this.object_indices) {
            for (const name in object) {
                this.DVBOs.get(name).rebase(index,object[name]);
            }
        }
        // Copy arrays
        for (const [name,old_DVBO] of old_DVBOs) {
            this.DVBOs.get(name).copy_from(old_DVBO);
        }
    }
    delete(gl) {
        for (const [name,dvbo] of this.DVBOs) {
            dvbo.delete(gl);
        }
        gl.deleteVertexArray(this.vao);
    }
    make_object(index) {
        const object = {};
        for (const name in this.channels) {
            object[name] = this.DVBOs.get(name).acquire(index);
        }
        this.object_indices.set(object,index); // Saving for rebuilding
        return object;
    }
    acquire(gl) {
        if (this.recycled_objects.length > 0) {
            // We can re-use a recycled object.
            return this.recycled_objects.pop();
        } else {
            if (this.head < this.size) {
                // Create a new object
                const index = this.head;
                this.head += 1;
                return this.make_object(index);
            } else {
                // Out of space!
                this.expand(gl,this.size * 2);
                return this.acquire(gl);
            }
        }
    }
    relenquish(gl,object) {
        for (const name in object) {
            object[name].zeroeq(); // Zero out relenquished objects
        }
        this.recycled_objects.push(object);
    }
    draw(gl) {
        for (const [name,dvbo] of this.DVBOs) {
            dvbo.prepare(gl);
        }
        gl.bindVertexArray(this.vao);
        gl.drawArraysInstanced(gl.TRIANGLE_STRIP,0,4,this.head);
    }
}

function start(canvasManager) {
    const gl = canvasManager.gl;
    const sc = new ShaderCompiler(gl,
        {'shader':['shader-v','shader-f']},
    );
    for (const e of sc.errors) {
        console.log(e.toString());
    }
    const program = sc.programs.get('shader');
    //const uniforms = new Uniforms(sc.uniformProfiles.get('shader'));
    
    // Initial gl setup
    gl.useProgram(program);
    const t_loc = gl.getUniformLocation(program,"t");
    const view_loc = gl.getUniformLocation(program,"view");
    const view = new Mat();
    
    // VAO
    const vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    
    // Setting up square geometry to get around the,
    // "drawArraysInstanced: One active vertex attrib (if any are active) must have a divisor of 0."
    // bug.
    const square = new Float32Array([
        -1.0,-1.0,
        1.0,-1.0,
        -1.0,1.0,
        1.0,1.0,
    ]);    
    const square_buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, square_buffer);
    gl.bufferData(gl.ARRAY_BUFFER, square, gl.STATIC_DRAW);
    /*const vertex_loc = gl.getAttribLocation(program,'vertex');
    gl.vertexAttribPointer(vertex_loc, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(vertex_loc);*/
    // Setting up VAO/VBO stuff for instanced rendering
    /*const N_INSTANCES = 10000;
    const mat3_data = new Float32Array(N_INSTANCES);
    for (let i=0; i<mat3_data.length; ++i) {
        const j = i % 9;
        mat3_data[i] = 2.0*Math.random() - 1.0;
    }
    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, mat3_data, gl.STATIC_DRAW);
    const model_x_loc = gl.getAttribLocation(program,'s');
    gl.vertexAttribPointer(model_x_loc, 1, gl.FLOAT, false, 0, 0);
    gl.vertexAttribDivisor(model_x_loc, 1);
    gl.enableVertexAttribArray(model_x_loc);
    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, mat3_data, gl.STATIC_DRAW);
    const model_x_loc = gl.getAttribLocation(program,'model_x');
    gl.vertexAttribPointer(model_x_loc, 3, gl.FLOAT, false, 4*9, 4*0);
    gl.vertexAttribDivisor(model_x_loc, 1);
    gl.enableVertexAttribArray(model_x_loc);
    const model_y_loc = gl.getAttribLocation(program,'model_y');
    gl.vertexAttribPointer(model_y_loc, 3, gl.FLOAT, false, 4*9, 4*3);
    gl.vertexAttribDivisor(model_y_loc, 1);
    gl.enableVertexAttribArray(model_y_loc);*/
    
    const dvao = new DynamicVAO(gl,program,square_buffer,{
        "s":{'type':'scalar','dynamic':false},
    },1);
    //const object1 = dvao.acquire(gl);
    dvao.acquire(gl).s.set(0.1);
    dvao.acquire(gl).s.set(0.2);
    dvao.acquire(gl).s.set(0.3);
    dvao.acquire(gl).s.set(0.4);
    console.log(dvao);
    let timer = 0;
    let frames = 0;
    let last_t = null;
    (function loop(t) {
        cm.updateSize();
        if (last_t !== null) {
            const dt = t-last_t;
            timer += dt;
            frames += 1;
            if (timer > 100) {
                const fps = 1000*frames/timer;
                document.getElementById("fps").textContent = fps.toFixed(3) + " fps";
                frames = 0;
                timer = 0;
            }
            view.translationeq(cm.mouse_x,cm.mouse_y);
            view.a[0] = 1/cm.aspectRatio;
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.uniform1f(t_loc,t*0.01);
            gl.uniformMatrix3fv(view_loc,false,view.a);
            dvao.draw(gl);
            //gl.drawArraysInstanced(gl.TRIANGLE_STRIP,0,4,N_INSTANCES);
        }
        last_t = t;
        window.requestAnimationFrame(loop);
    })(null);
}

const cm = new CanvasManager(document.getElementById("canvas-container"));
if (cm.gl !== null) {
    start(cm)
};

</script>

</div>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <script src="sounds.js"></script>
</head>
<body>
<h1>Basic Tests: WebGL</h1>

<canvas id="canvas" width=600 height=600></canvas>

<script id="shader-v" type="x-shader/x-vertex">#version 300 es
out vec3 vcolor;
uniform float t;
const vec2 square[4] = vec2[4](
    vec2(0.0,0.0),
    vec2(1.0,0.0),
    vec2(0.0,1.0),
    vec2(1.0,1.0)
);
void main() {
    float s = float(gl_InstanceID)/4096.0;
    mat2 m = mat2(
        sin(s*t)*s, cos(s*t)*s,
        -cos(s*t)*s, sin(s*t)*s
    )*2.0;
    gl_Position = vec4(m*square[gl_VertexID],1.0,1.0);
    
    vcolor = vec3(square[gl_VertexID],0.5);
}
</script>

<script id="shader-f" type="x-shader/x-fragment">#version 300 es
precision highp float;
out vec4 color;
in vec3 vcolor;

void main() {
    color = vec4(vcolor, 1.0);
}
</script>
<script>

/* Support class for instanced drawing. Provides a parameter allocation pool for instanced drawing. */
class HeapVBO {
    constructor(gl,signature,initial_size=1) {
        this.signature = signature; // Type signature
        this.dirty = false; // Flag for when we need to send new data to the gpu.
    }
}

class ShaderCompilerError {
    constructor(context,log) {
        this.context = context;
        this.log = log;
    }
    toString() {
        return this.context + '\n' + this.log;
    }
}

class ShaderCompiler {
    constructor(gl,programs={}) {
        if (! (programs instanceof Map) ) { // If shaders is not already a map
            programs = new Map(Object.entries(programs));
        }
        this.errors = []; // A list of errors
        // Load shaders
        const vshaders = new Map();
        const fshaders = new Map();
        for (const [name,[vname,fname]] of programs) {
            this.loadShader(vname,vshaders,gl.VERTEX_SHADER);
            this.loadShader(fname,fshaders,gl.FRAGMENT_SHADER);
        }
        // Compile shaders
        this.compileShaders(vshaders,gl.VERTEX_SHADER);
        this.compileShaders(fshaders,gl.FRAGMENT_SHADER);
        // Log errors in shader compilation.
        this.checkShaders(vshaders);
        this.checkShaders(fshaders);
        // Link programs
        this.linkPrograms(programs,vshaders,fshaders);
        // Log errors in linking
        this.checkPrograms(programs);
        // Check uniforms and attributes
        this.analyzePrograms(programs);
        // Compilation done, we can save the map now.
        this.programs = programs;
    }
    error(context,log) {
        this.errors.push(new ShaderCompilerError(context,log));
    }
    loadShader(name,map,type) {
        const element = document.getElementById(name);
        if (map.has(name)) return; // memoization
        if (element !== null) {
            const correctType = type === gl.VERTEX_SHADER ? "x-shader/x-vertex" : "x-shader/x-fragment";
            if (element.type === correctType) {
                map.set(name,element.textContent);
                return;
            } else {
                this.error(name,"Element type is `"+element.type+"` but it should be `"+correctType+"`.");
            }
        } else {
            this.error(name,"No element with id `"+name+"`. Shader source not found.");
        }
        map.set(name,null);
    }
    compileShaders(map,type) {
        for (const [name,source] of map) {
            if (source !== null) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader,source);
                gl.compileShader(shader);
                map.set(name,shader);
            }
        }
    }
    checkShaders(map) {
        // Checking shaders separately from compilation lets the driver compile in parallel
        for (const [name,shader] of map) {
            if (shader !== null) {
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { // Blocks until compiled
                    this.error(name,gl.getShaderInfoLog(shader));
                    map.set(name,null);
                }
            }
        }
    }
    linkPrograms(programs,vshaders,fshaders) {
        for (const [name,[vname,fname]] of programs) {
            const [vshader,fshader] = [vshaders.get(vname),fshaders.get(fname)];
            if (vshader !== null && fshader !== null) {
                const program = gl.createProgram();
                gl.attachShader(program,vshader);
                gl.attachShader(program,fshader);
                gl.linkProgram(program);
                programs.set(name,program);
            } else {
                programs.delete(name);
            }
        }
    }
    checkPrograms(programs) {
        for (const [name,program] of programs) {
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                this.error(name,gl.getShaderInfoLog(program));
                programs.delete(name);
            }
        }
    }
    analyzePrograms(programs) {
        for (const [name,program] of programs) {
            const nattributes = gl.getProgramParameter(program,gl.ACTIVE_ATTRIBUTES);
            const nuniforms = gl.getProgramParameter(program,gl.ACTIVE_UNIFORMS);
            console.log(name,"has",nattributes,"attributes and",nuniforms,"uniforms.");
        }
    }
}

function start(canvas,gl) {
    let last_t = null;
    const sc = new ShaderCompiler(gl,
        {'shader':['shader-v','shader-f']},
    );
    for (const e of sc.errors) {
        console.log(e.toString());
    }
    const program = sc.programs.get('shader');
    
    // Initial gl setup
    gl.useProgram(program);
    const t_loc = gl.getUniformLocation(program,"t");
    gl.clearColor(0.5, 0.5, 0.5, 1.0);
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.GREATER);
    gl.clearDepth(0.0);
    (function loop(t) {
        if (last_t !== null) {
            const dt = t-last_t;
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.uniform1f(t_loc,t*0.01);
            gl.drawArraysInstanced(gl.TRIANGLE_STRIP,0,4,4096);
        }
        last_t = t;
        window.requestAnimationFrame(loop);
    })(null);
}

const canvas = document.getElementById("canvas");
const gl = canvas.getContext("webgl2");

if (gl !== null) {
    start(canvas,gl);
} else {
    console.log("Can't get context.");
}

</script>

</div>
</body>
</html>

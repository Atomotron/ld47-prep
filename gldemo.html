<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <script src="math32.js"></script>
    <script src="shadercompiler.js"></script>
    <script src="imageloader.js"></script>
    <script src="sounds.js"></script>
    <script src="canvasmanager.js"></script>
    <script src="dynamicvao.js"></script>
    <script src="scene.js"></script>
    <script src="engine.js"></script>
</head>
<body>
<h1>Basic Tests: WebGL</h1>
<div id="canvas-container" style="height:80vh; width:100%"></div>

<script id="shader-background-v" type="x-shader/x-vertex">#version 300 es
in vec2 vertex;
out vec2 world_coord;
uniform mat3 inverse_view;

void main() {
    gl_Position = vec4(vertex,0.0,1.0);
    world_coord = (inverse_view * vec3(vertex,1.0)).xy;
}
</script>

<script id="shader-background-f" type="x-shader/x-fragment">#version 300 es
precision highp float;
out vec4 color;
in vec2 world_coord;

void main() {
    color = vec4(world_coord*0.1+0.5, 0.5, 1.0);
}
</script>
<script>

/*
 * A custom render pass that uses the custom shaders
 */
class BackgroundPass extends RenderPass {
    constructor(gl,scene,program) {
        super(gl,program);
        this.vao = new SimpleVAO(gl,program,scene.square_vao);
        this.inverse_view_loc = gl.getUniformLocation(program,"inverse_view");
        this.inverse_view = new Mat();
        this.t = 0;
    }
    update(scene,dt) {
        Mat.Inv(this.inverse_view,scene.view);
        this.t += dt;
    }
    draw(gl) {
        gl.useProgram(this.program);
        gl.uniformMatrix3fv(this.inverse_view_loc,false,this.inverse_view.a);
        this.vao.draw(gl);
    }
}

class DemoEngine extends Engine {
    setup() {
        // Background pass
        this.backgroundpass = new BackgroundPass(this.gl,
            this.scene,
            this.sc.programs.get('background')
        );
        this.scene.addPass(this.backgroundpass,1.0);
        // Make some sprites
        this.sprites = new Set();
        for (const [name,tex_frame] of this.il.model_frames) {
            const s = new Sprite(this,name);
            s.angle = Math.PI * 2 * Math.random();
            s.scale = 0.5 + 0.5*Math.random();
            s.pos = new Vec(Math.random()*2-1, Math.random()*2-1);
            s.mirror = Math.random() > 0.5;
        }
    }
    update(dt) {
        super.update(dt);
        this.scene.view.translationeq(new Vec(this.cm.mouse_x,this.cm.mouse_y));
        this.scene.view.a[0] = 1/this.cm.aspectRatio;
    }
}

const engine = new DemoEngine(
    canvas_container = document.getElementById("canvas-container"),
    shader_programs = {
        background:['shader-background-v','shader-background-f']
    },
    images = {
        spritesheet:'images/hoverbots.png'
    },    
    frames = {
        spritesheet:'images/hoverbots.json'
    },
    music = {
        "negentropy": "sound/Chad_Crouch_-_Negentropy.mp3"
    },
    sfx = {
        "hit": "sound/hit.mp3"
    },
);

</script>

</div>
</body>
</html>
